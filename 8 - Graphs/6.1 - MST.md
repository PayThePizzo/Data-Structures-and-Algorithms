# Minimum Spanning Trees

## Spanning Trees
We can apply this concept to undirected, connected graphs G=(V,E).
A spanning tree is a **tree** T=(V,E') where <mark>subset E'âŠ† E such that, 
all vertices are reached by these edges.</mark>

![ex st](https://github.com/PayThePizzo/DataStrutucures-Algorithms/blob/main/Resources/exst.png?raw=TRUE)

## MST
Let G be an undirected, connected, weighted graph G=(V,E, w), where w is a weight function
`w:E->R`. 

A tree TâŠ†E, is a MST, if the weight of the tree <mark>`W(T) = sum(w(u,v), (u,v)âˆˆT)`</mark> is one of
the minimum spanning trees out of all the spanning trees

![ex mst](https://github.com/PayThePizzo/DataStrutucures-Algorithms/blob/main/Resources/exmst.png?raw=TRUE)

In fact, the minimality factor implies the fact we are working with weighted graphs.

If a graph is connected i.f.f. there exists at least one MST for that graph.

---

### Algorithm for MST: crucial fact of MST
Our focus will be primarily on the SMT search. 
Two very famous algorithms for this are **Kruskal** and **Prim**.

But what do all algorithms of SMT search have in common?
If we execute a cut on a graph, and we take a light edge crossing the cut, 
**there exists a MST containing that light edge**.

### Sew and Cut technique 
Let's consider a T, a generic MST of G, and suppose there is an edge (u,v) in 
the cut. We can have now this scenario.
* (u,v)âˆˆT
* (u,v)âˆ‰T

With this technique we can construct another MST that contains the edge, from
the Tree T (which does not contain the edge (u,v) ).
1. Let's sew: T âˆª{(u,v)} 
   1. We have now a cyclic graph.
   2. (x,y)âˆˆE is the cycle created, which crosses the cut
2. Let's cut: <mark>T' = T âˆª{(u,v)}\{(x,y)}</mark> is a MST.
   1. W(T') = W(T), with W(T) is a MST.
   
---

## Generic MST
Let's start with an incremental general algorithm thought to find MSTs for a graph.

Input:
* G, the graph
* w, a vector containing the weights

Output:
* an MST

Steps:
1. Construct a set A that will contain the edges of the MST 
2. While |A| < |V| âˆ’ 1
3. Find a safe edge for A(u,v)
4. Add it to A
6. Return A

```python
Generic_MST(G, w)
    A[] = âŠ˜; #Empty Set
    while (|A| < |V| âˆ’ 1):
        #find a safe edge for A (ð‘¢, ð‘£) âˆˆ ð¸
        ð´ â† ð´ âˆª {(ð‘¢, ð‘£)}
    return A;
```

Since the third step is not clear, we cannot really implement it. Mind that,
this is only an example and the algorithms we are going to see are mere variations.

---

## Fundamental Theorem of MST
To introduce this theorem we must mind the following definitions:
1. Cut (S, V\S) SâŠ†V
2. Light Edge
3. Safe Edge

Let G=(V,E, w) an undirected, connected, weighted graph, if:
1. **AâŠ†E**, that is included in some MST for G.
2. **(S, {V\S})** be any cut of G that **respects A**
   1. No edge of A crosses (S, {V\S})
3. **(u,v)âˆˆE** be a light edge crossing the cut (S, {V\S})

Then, **edge (u,v) is safe for A**
* **Aâˆª{(u,v)}** is included in some MST

This helps find a starting point to finish the algorithm we have previously
tried to implement!

Dim: Let TâˆˆE be a MST including A. We have two cases
1. (u,v)âˆˆT
   1. We stop here, since we found a tree where A âˆª {(u,v)} âŠ† T is an MST
2. (u,v)âˆ‰T
   1. We proceed like in the see&cut technique
   2. We sew: T âˆª {(u,v)}
      1. The result is a cycle
   3. We cut: T' = T âˆª{(u,v)}\{(x,y)}, which is an MST
      1. T' is an ST
      2. W(T') = W(T)
         1. W(T)<=W(T'), because T is an MST
         2. W(T')<=W(T), because W(T')=W(T)+W((u,v))-W(x,y)
            1. W((u,v))-W(x,y)<=0 because W((u,v))<=W(x,y) since (u,v) is a light edge
   4. We need to find whether Aâˆª{(u,v)} âŠ† T', with T' being an MST
      1. (u,v)âŠ† T', is true by construction 
      2. AâŠ† T', is true
         1. If (x,y)âŠ†A then we cannot prove our point
         2. But, we know the cut respects A, by hypothesis
         3. So, surely (x,y) crosses the cut and (x,y)âˆ‰A

#### Observation 1:
w(u,v) = w(x,y), they have the same weight!
* Since T was an MST, but also T' is an MST. 

This means there these edges are both light edges, with the same weight, and both cross the cut.
* If we have a graph, with different weights for each edge, and we execute a cut the light edge is obviously
unique
* Trivially, when we "Sew" we have at least two light edges. But here there is only one!

#### Observation 2:
Given a cut (S, {V\S}), with SâŠ†V. 
* If the light edge (u,v) crossing the cut, is unique
* Then, all MST include (u,v)

#### Corollary 23.2[CLRS]:
Let G=(V,E) be a connected, undirected graph with a 
real-valued weight function w defined on E. 
* Let AâŠ†E, included in some minimum spanning tree for G
* Let C=(V(C), E(C)) be a connected component (tree) in the
  forest G(A) = (V,A)
* If (u,v) is a light edge connecting C to some other component in G(A)

Then (u,v) is safe for A

![ex cor 23](https://github.com/PayThePizzo/DataStrutucures-Algorithms/blob/main/Resources/excor23.png?raw=TRUE)

