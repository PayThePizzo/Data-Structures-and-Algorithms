# Minimum Spanning Trees

## Spanning Trees
We can apply this concept to undirected, connected graphs G=(V,E).
A spanning tree is a **tree** T=(V,E') where <mark>subset E'âŠ† E such that, 
all vertices are reached by these edges.</mark>

![ex st](https://github.com/PayThePizzo/DataStrutucures-Algorithms/blob/main/Resources/exst.png?raw=TRUE)

## MST
Let G be an undirected, connected, weighted graph G=(V,E, w), where w is a weight function
`w:E->R`. 

A tree TâŠ†E, is a MST, if the weight of the tree <mark>`W(T) = sum(w(u,v), (u,v)âˆˆT)`</mark> is one of
the minimum spanning trees out of all the spanning trees

![ex mst](https://github.com/PayThePizzo/DataStrutucures-Algorithms/blob/main/Resources/exmst.png?raw=TRUE)

In fact, the minimality factor implies the fact we are working with weighted graphs.

If a graph is connected i.f.f. there exists at least one MST for that graph.

### Algorithm for MST: crucial fact of MST
Our focus will be primarily on the SMT search. 
Two very famous algorithms for this are **Kruskal** and **Prim**.

But what do all algorithms of SMT search have in common?
If we execute a cut on a graph, and we take a light edge crossing the cut, 
**there exists a MST containing that light edge**.

### Sew and Cut technique 
Let's consider a T, a generic MST of G, and suppose there is an edge (u,v) in 
the cut. We can have now this scenario.
* (u,v)âˆˆT
* (u,v)âˆ‰T

With this technique we can construct another MST that contains the edge, from
the Tree T (which does not contain the edge (u,v) ).
1. Let's sew: T âˆª{(u,v)} 
   1. We have now a cyclic graph.
   2. (x,y)âˆˆE is the cycle created, which crosses the cut
2. Let's cut: <mark>T' = T âˆª{(u,v)}\{(x,y)}</mark> is a MST.
   1. W(T') = W(T), with W(T) is a MST.
   
---

## Generic MST
Let's start with an incremental general algorithm thought to find MSTs for a graph.

Input:
* G, the graph
* w, a vector containing the weights

Output:
* an MST

Steps:
1. Construct a set A that will contain the edges of the MST 
2. While |A| < |V| âˆ’ 1
3. Find a safe edge for A(u,v)
4. Add it to A
6. Return A

```python
Generic_MST(G, w)
    A[] = âŠ˜; #Empty Set
    while (|A| < |V| âˆ’ 1):
        #find a safe edge for A (ð‘¢, ð‘£) âˆˆ ð¸
        ð´ â† ð´ âˆª {(ð‘¢, ð‘£)}
    return A;
```

Since the third step is not clear, we cannot really implement it. Mind that,
this is only an example and the algorithms we are going to see are mere variations.

---

### Fundamental Theorem of MST
To introduce this theorem we must mind the following definitions:
1. Cut (S, V\S) SâŠ†V
2. Light Edge
3. Safe Edge

